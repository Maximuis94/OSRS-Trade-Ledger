"""
Module with various widgets for displaying information in the GUI;
listed in the grid, given a list of strings.
Labels (pretty straightforward...)
Pop-up windows; small interfaces that are generated by the GUI for a single purpose.
E.g. show a detailed explanation, get user input (set configs, manually alter entries, ...)
Pop-up windows are usually removed once they have served their purpose.
The listbox has a separate module.

"""
import threading
import time
import tkinter as tk
from abc import abstractmethod
from collections.abc import Iterable, Callable
from tkinter import ttk

from overrides import override

import util.str_formats
import util.gui as ug
from gui.model.button import GuiButton
from gui.model.gui_widget import GuiWidget
from gui.model.grid import Grid
from global_variables.classes import SingletonMeta
from tasks.async_task import AsyncTask


class GuiLabel(GuiWidget):
    """
    Class for a label. # TODO move to separate module
    
    """
    def __init__(self, frame, g: Grid, text: str = '',
                 str_var: tk.StringVar = None,
                 event_bindings: Iterable = None,
                 font: tuple = ('Helvetica', 10),
                 width: (int, float) = None,
                 justify: str = 'left', **kwargs):
        """ Class for setting up tk label widget.
        A tk.Label built on top of the given frame with frequently used attributes, used to define tk elements in a
        standardized fashion. Commonly tweaked parameters can be passed as well. All parameters with the exception of
        grid correspond to attributes used in original tk objects.

        Parameters
        ----------
        frame : ttk.Frame
            The ttk frame on which the Label will be placed.

        Attributes
        ----------
        frame : ttk.Frame
            Frame on which the object will be placed

        Methods
        -------
        set_text(string)
            Method for changing the text displayed by the label
        """
        if not isinstance(str_var, tk.StringVar):
            str_var = tk.StringVar(self.frame)
        super().__init__(self.frame, widget_name='GuiLabelWidget', font=font, width=width, justify=justify,
                         event_bindings=event_bindings, **kwargs)
        self.set_text(text=text)
        
    def set_text(self, text: str):
        """ Display the given `text` string in this label """
        if not isinstance(text, str):
            text = str(text)
        self.set_value(value=text, var_key='label_text')
    
    def get_text(self) -> str:
        """ Get the text displayed by this label """
        return self.tk_vars.get('label_text').get()
    

class GuiCounter(SingletonMeta, AsyncTask):
    def __init__(cls, task, **kwargs):
        super().__init__(task=task, **kwargs)
    
    def set_task(self, task: Callable):
        self.task = task
    
    def set_oncomplete(self, oncomplete: Callable):
        self.on_complete = oncomplete
        

class PopUpWindow(tk.Toplevel):
    """
    Base class for pop-up windows.
    Pop-up windows are not directly linked to the main GUI; but more like a dialogue interface that can be used to
    provide a more detailed explanation without having to flood the GUI with text, or it can be used to get user input,
    for instance.
    
    A callback method can be passed to the constructor, this method will be called right before the pop-up window is
    destroyed, passing a data dict as arg
    
    # TODO move to separate module
    """
    def __init__(self, window_title: str = '', window_size: tuple = (300, 300), on_close_callback: Callable = None, **kwargs):
        
        super().__init__(**kwargs)
        self.title(window_title)
        self.geometry(f"{window_size[0]}x{window_size[1]}")
        self.on_close_callback = on_close_callback
        self.data = {}
        
        self.proceed = ug.tk_var(True, 'ThreadActive', master=self)
        self.text = 'Tekst'
        self.var = ug.tk_var(value=self.text, master=self)
        self.label = tk.Label(self, textvariable=self.var, font=('Helvetica', 20))
        self.label.grid(row=0, rowspan=1, columnspan=1, column=0)
        self.button = tk.Button(self, text='Start/stop', command=self.start_counter)
        self.button.grid(row=1, rowspan=1, columnspan=1, column=0)
        self.t0 = 0
        self.t = AsyncTask(self.start_counter, name='Counter', daemon=True)
        self.t.start()
        self.bind('-', self.start_counter)
        
    def start_counter(self, e=None, max_value: int = None):
        """ Start the counter and update the display """
        if self.t0 == 0:
            self.t0 = time.perf_counter()
            time.sleep(.1)
            while max_value is None or time.perf_counter() - self.t0 < max_value:
                t0 = self.t0
                self.text = util.str_formats.delta_t(int(time.perf_counter()-t0))
                self.update_label()
                time.sleep(.5)
                
                # If the counter is reset, terminate the thread running the old counter
                if not self.proceed.get():
                    self.proceed.set(True)
                    exit(-1)
            self.t0 = 0
        else:
            self.t0 = 0
            self.proceed.set(False)
            self.t = AsyncTask(self.start_counter, name='Counter', daemon=True)
            self.t.start()
    
    def update_label(self):
        self.var.set(self.text)
        # self.label = tk.Label(self.frame, text=self.text, textvariable=self.var)
        # self.master.after(2000, self.update_label)
    
    @override
    def destroy(self):
        """ Method to execute when the pop-up windows task is fulfilled. Configured callback is invoked + destroy. """
        if self.on_close_callback is not None:
            self.on_close_callback(self.data)
        super().destroy()


class TestPopUp(tk.Toplevel):
    """
    Base class for pop-up windows.
    Pop-up windows are not directly linked to the main GUI; but more like a dialogue interface that can be used to
    provide a more detailed explanation without having to flood the GUI with text, or it can be used to get user input,
    for instance.

    A callback method can be passed to the constructor, this method will be called right before the pop-up window is
    destroyed, passing a data dict as arg

    # TODO move to separate module
    """
    
    def __init__(self, window_title: str = '', window_size: tuple = (300, 300), on_close_callback: Callable = None,
                 **kwargs):
        
        super().__init__(**kwargs)
        self.title(window_title)
        self.frame = ttk.Frame()
        self.geometry(f"{window_size[0]}x{window_size[1]}")
        self.on_close_callback = on_close_callback
        self.data = {}
        self.button = GuiButton(self.frame, command=lambda e: True, width=10, tag='A',dims=(0, 0, 5, 3))
        # self.button.
    
    @override
    def destroy(self):
        """ Method to execute when the pop-up windows task is fulfilled. Configured callback is invoked + destroy. """
        if self.on_close_callback is not None:
            self.on_close_callback(self.data)
        super().destroy()


if __name__ == "__main__":
    root = tk.Tk()
    popup = TestPopUp('counter')
    # frm = ttk.Frame(root, padding=10)
    # frm.grid()
    root.mainloop()