"""
Module with various widgets for displaying information in the GUI;
listed in the grid, given a list of strings.
Labels (pretty straightforward...)
Pop-up windows; small interfaces that are generated by the GUI for a single purpose.
E.g. show a detailed explanation, get user input (set configs, manually alter entries, ...)
Pop-up windows are usually removed once they have served their purpose.
The listbox has a separate module.

"""
import tkinter as tk
from collections.abc import Iterable, Sized
from tkinter import ttk
from typing import Optional

from gui.base.frame import GuiFrame
from gui.base.widget import GuiWidget
from gui.util.str_formats import shorten_string


class GuiLabel(ttk.Label, GuiWidget):
    """
    Class for a label.
    
    """
    
    
    def __init__(self, frame: GuiFrame, tag: str, text: str = None, text_variable: tk.StringVar = None,
                 event_bindings: Sized and Iterable = None, **kwargs):
        """ Class for setting up tk label widget.
        A tk.Label built on top of the given frame with frequently used attributes, used to define tk elements in a
        standardized fashion. Commonly tweaked parameters can be passed as well. All parameters with the exception of
        grid correspond to attributes used in original tk objects.

        Parameters
        ----------
        frame : ttk.Frame
            The ttk frame on which the Label will be placed.

        Attributes
        ----------
        frame : ttk.Frame
            Frame on which the object will be placed

        Methods
        -------
        set_text(string)
            Method for changing the text displayed by the label
        """
        self.init_widget_start(frame, tag, text=text, text_variable=text_variable, **kwargs)
        
        super().__init__(self.frame._frame, textvariable=self._text, font=self.font.tk)
        self.init_widget_end(event_bindings=event_bindings, **kwargs)
    
    def update_label_text(self, text: str):
        """ Update the text displayed by the label. """
        if self._MAX_LENGTH is not None and len(text) > self._MAX_LENGTH:
            text = shorten_string(text, self._MAX_LENGTH)
            
        self._text.set(text)
